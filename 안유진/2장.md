
## 2장

> 숫자 표현 및 산술 연산을 하는 반가산기, 전가산기, n 비트 가산기, 증분기로 '산술 논리 연산 장치(Arthmetic Logical Unit, **`ALU`**)'를 만든다. 

<br>

### 1. 새롭게 알게 된 내용 
* 조합 논리회로
	* 반가산기
		* **두 개의 1비트 입력에 대해 sum과 carry 계산**
		* `XOR` 게이트(sum 계산) + `AND` 게이트(carry 계산)
            * *XOR은 두 입력값이 다를 때 1 출력*
            * *AND는 두 입력값 모두가 1일 때 1 출력* 
		* carry를 이전 비트에서 받아들이지 못 함
	* 전가산기
		* **세 개의 1비트 입력에 대해 sum과 carry 계산**
		* 반가산기의 한계를 보완해 **carry-in까지 고려** (`a와 b와 carry-in의 AND` 계산 가능) 
		* 반가산기 2개 +  `OR` 게이트
            * *OR은 두 입력값 중 하나라도 1일 때 1 출력*
            * *(a ⋅ b), (carry-in ⋅ (a ⋅ b)) 둘 중 하나라도 참이면 1이 되어야 하므로 OR 게이트로 (a ⋅ b) + (carry-in ⋅ (a ⋅ b)) 계산*
	* n 비트 가산기
		* **여러 개의 전가산기를 직렬로 연결**해 멀티비트 연산 수행
		* carry 전파 지연 문제를 해결하기 위해 carry lookahead adder 를 사용하기도 함
	* 증분기
		* 입력된 숫자에 +1을 하는 간단한 회로
		* 현재 명령 실행 후 다음 명령을 가져오는 데에 사용
		* 가산기로도 x + 1 연산 구현이 가능하지만 전용 증분기 칩이 더 효율적
* ALU는 논리 게이트, 가산기, 증분기 등의 **조합 논리 회로**와 레지스터, 플립플롭과 같은 **순차 논리회로**로 구성 
* 용어
	* 최상위 비트(Most Significant Bit, **`MSB`**): 가장 왼쪽 숫자, 부호 결정
	* 최하위 비트(Least Significant Bit, **`LSB`**): 가장 오른쪽 숫자, 짝수/홀수 판별
	* 자리올림(carry): 덧셈 연산에서 자릿값을 초과하면 발생하는 값
	* 오버플로(overflow): 부호 있는 연산에서 값이 표현 범위를 초과할 때 발생(최상위 비트를 더하고 나서도 자리올림수가 1인 경우)
	* 2의 보수법(two's complement): 부호가 있는 2진법 코드의 효율적 표현법
		* n 비트 2진법 체계에서 **음수 x = 2^n - x** *(기수의 보수법(radix complement) 표현)*
		* 덧셈과 뺄셈의 처리방식이 동일해서 하드웨어 구현이 단순해짐 
* 컴퓨팅 시스템 전체 기능 중 어떤 기능을 어디에서 처리하게 할지 설계할 때 비용-성능 간의 트레이드오프를 고려해야 함
	* ALU(하드웨어) -> 고비용 - 고효율
		* 특정 기능을 전용 회로로 구현하면 병렬 처리 및 CPU 부하 감소를 통해 연산을 빠르게 하지만 유연성이 낮고 비용이 높음
	* OS(소프트웨어) -> 저비용 - 저효율
		* 업데이트를 통한 유연성과 CPU에서 실행되므로 비용이 낮으나 역시 CPU에서 실행되므로 속도가 상대적으로 느림
* 모든 고수준 언어는 **추상화 기법**을 통해 고정된 레지스터가 허용한 최소 최대 값보다 더 크거나 작은 값 표현이 가능함
	* 굉장히 비용이 큰 작업이므로 매우 크거나 매우 작은 숫자 처리 시에만 사용이 권고됨
* n 비트 2진법 체계에서 
	* -(2^(n-1)) 부터 2^(n-1) - 1까지 2^n개의 부호 있는 숫자 표현 가능 
	* 최상위 비트가 부호를 결정함
		* 음수 아닌 수는 모두 0으로 시작
		* 음수는 모두 1로 시작
	* x의 모든 비트를 뒤집고 그 결과에 1을 더하면 -x의 코드가 됨
* 운영체제의 주요 역할 중 하나는 프로그래머가 사용하는 추상화된 고수준 언어와 그 추상화가 구현되는 하드웨어 사이의 격차를 매우는 것

### 2. 흥미로웠던 점
* 2의 보수법
	* 코드 공간을 두 부분집합으로 나누어서 반은 음수가 아닌 숫자, 반은 음수를 표현하는 점
	* 부호 있는 숫자들의 덧셈과 뺄셈에 특별한 하드웨어가 필요 없음
	* 산술 연산을 포함하여 디지털 컴퓨터에서 수행되는 모든 함수는 **2진수의 덧셈**으로 환원 가능
* ALU에서 x, y값을 입력하고 제어비트를 설정하면 정의된대로 출력값이 표현됨
	- **e.g)** x - 1의 결과를 만들고 싶다면 아래 표를 참고해 제어비트를 001110으로 설정하면 됨!

        ![](./images/Screenshot%202025-02-24%20at%204.14.17%20PM.png)

### 3. 어려웠거나 궁금했던 점
* 어떤 두 n비트 숫자를 더했을 때 오버플로 발생 시 처리 방법
	* n개 비트 모두 다 올바른 결과임을 보장하는 데 만족하고 그 결과가 명확하고 뚜렷하다면 그냥 무시하는 것도 방법이다?
	* 무시하는 게 어떻게 방법이지?

### 4. 인상깊었던 구절
* "하드웨어 산업에서 단순하고 우아한 설계는 늘 성공한다."

