## 1장

> 가장 기초적인 논리게이트 Nand를 통해서 Not, And, Or, Xor 게이트, 멀티플렉서, 디멀티플렉서를 만든다.
> Not, And, Or, Xor은 기본적인 논리 연산자를 구현하고, 멀티플렉서와 디멀티플렉서는 데이터의 흐름을 제어한다. 

### 1. 새롭게 알게 된 내용 
* **게이트별 논리**
	* Nand(Not-And): 부정 논리곱
		* if ((a\==1) and (b\==1)) then out = 0, else out = 1
	* And: 논리곱
		* if((a\==1) and (b\==1)) then out = 1, else out = 0
	* Or: 논리합
		* if((a\==1) and (b\==1)) then out = 1, else out = 0
	* Not(inverter): 논리부정
		*  if (in\==0) then out = 1, else out = 0
	* Xor(exclusive or): 배타적논리합
		* if (a!=b) then out = 1, else out = 0
	* Mux(Multiplexor): 직렬화
		* if (sel\==0) then out=a, else out=b
	* DMux(Demultiplexor): 역직렬화
		* if (sel\==0) then {a, b} = {in, 0}, else {a, b} = {0, in}
* **모든 불함수는 Nand 게이트만 가지고 구현 가능**
	* 모든 불함수는 And, Or, Not 게이트로 구현이 가능한데, **드모르간의 법칙**에 따라 Or은 Not과 And로 표현할 수 있기 때문에 Not-And를 의미하는 Nand 게이트만으로도 모든 불함수를 구현할 수 있다.
* **어떠한 불 함수의 진리표가 있다면, 그 진리표에서 그 함수를 구현하는 불표현식 합성 가능**
	* 모든 불 함수는 어떠한 불 표현식으로 표현 가능하기 때문이다.
* **하드웨어 최적화의 첫걸음은 '불표현식 단순화' = NP-난해 문제를 푸는 것!**
* **HDL(Hardware Development Language)**
	* 하드웨어 칩 설계 시 회로의 동작과 구조를 기술하는 데 사용하는 언어 
	* HDL 코드를 기반으로 시뮬레이션, 검증, 실제 하드웨어의 합성이 이루짐
	* 내부 핀은 HDL 프로그램에서 처음 등장할 때 자동으로 생성됨
	* 핀의 출력선에는 제한이 없음 *(e.g. 하나의 입력 'a'가 동시에 두개의 And 게이트에 연결됨)*
* **불 함수 vs 불 표현식 vs 불 대수 vs 접두어 표기법**
	* **`불 함수`**: 함수 형태로, 입력들을 받아 논리 연산을 수행하는 모듈  ***e.g.** And(a, b, c)*
	* **`불 표현식`**: 사람에게 읽기 쉬운 형태로 논리식을 표현  ***e.g.** a And b And c*
	* **`불 대수`**: 결합법칙 등 대수적 성질 강조  ***e.g.**  a∙b∙c = (a ∙ b)∙c*
	* **`접두어 표기법`**: 연산자를 먼저 두어, 연산 순서를 명확히 하는 폴란드 표기법 사용  ***e.g.** And(And(a, b), c)*
* **컴퓨터 하드웨어는 멀티비트 값들을 처리하도록 설계됨**
	* n비트 게이트의 논리적 구조는 n값 *(e.g. 16, 32, 64비트)* 과 무관하게 동일
		 ***e.g.** in과 out이 16비트 값이라고 한다면, out[3] = in[5]는 out의 세 번째 비트 값을 in의 다섯 번째 비트 값으로 설정한다는 의미*
	* 비트는 오른쪽에서 왼쪽으로 인덱스가 부여됨(16비트라면 맨 오른쪽 비트는 0번째, 맨 왼쪽 비트는 15번째)
* 게이트 인터페이스는 유일하지만 인터페이스의 구현은 여러가지이고, 그 중 가장 효율적인 방법을 찾아야 한다. => 소프트웨어 개발 방식과 같다.

### 2. 어려웠거나 궁금했던 점 
* **Nand는 Not-And이고 Or이 빠져있는데 어떻게 Nand 게이트만으로 모든 불함수를 구현할 수 있는거지?** 
	* **드모르간의 법칙**에 따라 Or은 Not과 And로 표현할 수 있기 때문
		* Not(x And y) = Not(x) Or Not(y)
		* Not(x Or y) = Not(x) And Not(y)
* **Not(Nand(x, y))를 Nand로만 표현한다면?**
	* Not(x) = Nand(x, x)
	* Not(Nand(x, y)) = **Nand(Nand(x, y), Nand(x, y))**
	* 더 단순화할 수 있나? X
* **Not 게이트는 Nand 게이트 하나로 구현 가능**
	* Nand 게이트를 보면 두 입력이 모두 1일 때만 출력이 0이고, 그 외의 경우는 출력이 1이므로 두 입력을 동일하게 주면 Nand 게이트 하나로 Not 게이트를 구현할 수있다.
	* 즉, Not(x) = Nand(x, x)
* **'진리표로 표현되는 불 함수는 어떠한 표현식으로 표현될 수 있다'는 문장의 의미** </br>
	    = 진리표만 가지고 불 함수를 합성할 수 있다!
	* 부록 1 <불함수 합성> 
		* 함수가 1을 반환하는 행 i의 변수 값 조합을 제외한 나머지 모든 변수 값 조합들에 대해서 0을 반환하는 불 함수 f(i)를 각각 정의할 수 있다.
		* 이러한 함수 f(i)들은 변수 x, y, z각 1개 항씩, 총 3개 항의 논리곱(And)으로 표현할 수 있으며, 이때 행 i의 변수 값이 1인지 0인지에 따라 그 항은 변수 그 자체나 변수의 논리부정(Not)이 된다.
		* **진리표에서 불함수 f의 값이 1인 행을 OR로 연결** → 논리합 정규형(disjunctive normal form, DNF)
			* 논리곱(And) 함수 f(i)들을 모두 논리합(Or)으로 결합한 형태의 표현식
			* '곱의 합'의 불 대수 버전
			* miniterm들의 합
		* p.363 **f(i) 8개의 조합 중 f2, f4, f6 3개만 불함수 값이 1인 케이스**
			* f2, f4, f6은 불함수 f가 1이 되는 유일한 경우 
			* f(x, y, z) = f2(x, y, z) Or f4(x, y, z) Or f6(x, y, z)
				* f2(x, y, z) = Not(x) And y And Not(z)
				* f4(x, y, z) = x And Not(y) And Not(z)
				* f6(x, y, z) = x And y And Not(z)
			* f(x, y, z)를 논리합 정규형(DNF)으로 표현하면 (Not(x) And y And Not(z)) Or (x And Not(y) And Not(z)) Or (x And y And Not(z))


### 3. 추가내용
* **miniterm**
	* 특정 행(변수값 조합)에서만 1이 되는 식. 변수가 0이면 Not(x), 1이면 x로 놓고 모두 논리곱(AND)으로 표현 
* **15개 게이트 만들기 실습**
    * 어떠한 방식이든 정해진 인터페이스를 따르는 게이트를 구현한다. 
    * 단순할수록 게이트의 개수를 줄여 비용을 절감할 수 있다. 
	* **`기본 게이트`**
		* ~~Nand~~: 제공된 하드웨어 시뮬레이터에는 Nand의 내장형 구현이 이미 탑재되어있음
		* And
		* Or
		* Not
		* XOr
		* Mux
		* DMux
	* **`멀티비트 버전`**
		* Not16(16비트 Not)
		* And16(16비트 And)
		* Or16(16비트 Or)
		* Mux16(16비트 멀티플렉서)
	* **`다입력 버전`**
		* Or8Way
	* **`멀티비트 다입력 버전`**
		* Mux4Way16(4-입력 16비트 멀티플렉서)
		* Mux8Way16(8-입력 16비트 멀티플렉서)
		* DMux4Way(4-입력 1비트 디멀티플렉서)
		* DMux8Way(8-입력 1비트 디멀티플렉서)