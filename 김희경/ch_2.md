
## **주요 개념**

### **1. 비트(Bit)와 바이트(Byte)**
- **Bit**: 0 또는 1, 두 가지 상태만 표현하는 가장 작은 정보 단위
- **Byte**: 8비트의 묶음
### **2. LSB와 MSB**
- **LSB (Least Significant Bit, 최하위 비트)**: 숫자의 가장 오른쪽 비트 (가장 작은 값)
- **MSB (Most Significant Bit, 최상위 비트)**: 숫자의 가장 왼쪽 비트 (가장 큰 값, 부호 결정)
  - `MSB = 0`이면 양의 정수 (Positive Number)
  - `MSB = 1`이면 음의 정수 (Negative Number)
### **3. 캐리(Carry)와 오버플로우(Overflow)**
- **Carry**: 1비트와 1비트를 더한 뒤 발생한 **넘치는 1**을 다음 비트로 전달하는 것
- **Overflow**: **MSB(최상위 비트)에서 캐리가 발생**하여 올바른 범위를 벗어나는 것  
  - **Overflow가 발생할 경우 초과된 값을 무시하는 것이 공리(Axiom)이다.**

#### **예제: 4비트 2진법 체제에서의 표현**
- `0111 (7)` + `0001 (1)` = `1000 (-8)` → **Overflow 발생했고 이것을 무시하고 약속대로 -8이라 한다**
- **4비트 2진법에서는 `0~7(양수)`, `-1~-8(음수)`를 표현 가능**

---

## **새롭게 알게된 내용**

### **1. 1의 보수 (One’s Complement)**
- 모든 비트를 반전 (0 → 1, 1 → 0)
- 문제점: `0`과 `-0`이 존재하게 되어 중복 표현이 발생함

### **2. 2의 보수 (Two’s Complement) - 표준적인 방식**
- **1의 보수 + 1을 더한 값**
- 위의 `0` 중복 문제를 해결하여 컴퓨터에서 표준적으로 사용됨
- 보수법을 사용하면 **덧셈만으로 사칙연산을 수행 가능**

💡 **컴퓨터는 `A - B` 연산을 `A + (-B)`로 변환하여 수행한다.**
- **곱셈**: 반복적인 덧셈으로 구현됨
- **나눗셈**: 반복적인 뺄셈으로 수행 (실제로는 덧셈을 이용함)

---

### **1. 반가산기 (Half Adder)**
- 두 개의 비트를 입력받아 **Sum(합)과 Carry(올림값)**을 출력
- **이전 연산의 Carry를 받지 못하는 한계가 있음**

### **2. 전가산기 (Full Adder)**
- 두 개의 비트 + 이전 Carry 값을 입력받아 Carry와 Sum을 계산
- 반가산기의 한계를 극복하여 다중 비트 연산 가능

### **3. 여러 개의 전가산기를 연결하여 만든 가산기 (Adder 종류)**
- **리플 캐리 가산기 (Ripple Carry Adder)**: 캐리를 한 단계씩 넘겨가며 계산 (속도 느림)
- **캐리 룩어헤드 가산기 (Carry Lookahead Adder)**: 빠르게 캐리를 예측하여 연산 속도 향상
- **Kogge-Stone 가산기**: 고속 병렬 연산을 위해 최적화된 가산기

### **4. 증분기 (Incrementer)**
- 주어진 숫자에 **1을 더하는 회로**
- **보수를 만들 때 유용하게 사용됨** (특히 2의 보수 변환)

---

### **📌 HACK컴퓨터의 ALU의 제어 비트**
`zx`, `nx`, `zy`, `ny`, `f`, `no`는 ALU의 연산을 조작하는 제어 비트입니다.

| 제어 비트             | 값   | 설명                  |
|-----------------|---|-------------------|
| `zx` (Zero x)     | `1` | `x`를 0으로 설정         |
| `zx` (Zero x)     | `0` | `x`를 그대로 사용         |
| `nx` (Not x)      | `1` | `x`를 반전 (**NOT x**) |
| `nx` (Not x)      | `0` | `x`를 그대로 사용         |
| `zy` (Zero y)     | `1` | `y`를 0으로 설정         |
| `zy` (Zero y)     | `0` | `y`를 그대로 사용         |
| `ny` (Not y)      | `1` | `y`를 반전 (**NOT y**) |
| `ny` (Not y)      | `0` | `y`를 그대로 사용         |
| `f` (Function)    | `1` | `x + y` (산술 덧셈) 수행  |
| `f` (Function)    | `0` | `x & y` (비트 AND) 수행 |
| `no` (Not Output) | `1` | 최종 출력을 반전 (**NOT out**) |
| `no` (Not Output) | `0` | 최종 출력을 그대로 유지 |

---

## **ALU 제어 비트 연산 분석**

### **1️⃣ 첫 번째 행 (`zx=1, nx=0, zy=1, ny=0, f=1, no=0`)**
| 제어 비트 | 값 | 설명 |
|--------|---|----------------------------|
| `zx`   | 1 | `x = 0000` (강제로 0) |
| `nx`   | 0 | `x` 그대로 유지 (여전히 `0000`) |
| `zy`   | 1 | `y = 0000` (강제로 0) |
| `ny`   | 0 | `y` 그대로 유지 (여전히 `0000`) |
| `f`    | 1 | `x + y = 0000 + 0000 = 0000` |
| `no`   | 0 | 결과 그대로 (`0000`) |
| **`out`** | `0000` | 최종 출력 |

---

### **2️⃣ 두 번째 행 (`zx=1, nx=1, zy=1, ny=1, f=1, no=1`)**
| 제어 비트     | 값      | 설명                                    |
| --------- | ------ | ------------------------------------- |
| `zx`      | 1      | `x = 0000` (강제로 0)                    |
| `nx`      | 1      | `x` 반전 → `x = 1111` (1의 보수, 즉 `-1`)   |
| `zy`      | 1      | `y = 0000` (강제로 0)                    |
| `ny`      | 1      | `y` 반전 → `y = 1111` (1의 보수, 즉 `-1`)   |
| `f`       | 1      | `x + y = 1111 + 1111 = 1110` (2진수 덧셈) |
| `no`      | 1      | 결과 반전 → `NOT(1110) = 0001`            |
| **`out`** | `0001` | 최종 출력                                 |

---

## **🚀 결론**
- **컴퓨터는 2의 보수법을 사용하여 덧셈만으로 사칙연산을 수행한다.**
- **가산기(Adder)와 증분기(Incrementer)는 덧셈 및 보수 연산을 위한
