# 불 연산 (Boolean Arithmetic)
> 학습 목표
> 1. 2진 코드와 불 산술을 이용해 부호있는 정수 표현 및 덧셈
> 2. n비트 2진수 두 개를 덧셈하는 가산기 칩 정의
> 3. 시뮬레이터를 사용해 가산기 칩 만들기

<br>

## 산술 연산
### 2진수와 10진수

<br>

- 10진수
```
  6083 = 6 * 10³ + 0 * 10² + 8 * 10¹ + 3 * 10⁰ = 6083
```

<br>

- 10진수 -> 2진수 (나머지 분할법)
```
 '9'
÷ 2 … 1 => LSB
----
  4
÷ 2 … 0
----
  2
÷ 2 … 0
----
  1
÷ 2 … 1 => MSB
----
  0
```
1. 변환할 10진수를 숫자 2로 나눈다.
2. 몫과 나머지를 기록한다.
3. 나머지를 거꾸로 읽는다.

<br>

- 2진수 -> 10진수 (가중치 합산법)
```
 10011₂ = 1 * 2⁴ + 0 * 2³ + 0 * 2² + 1 * 2¹ + 1 * 2⁰ = 16 + 0 + 0 + 2 + 1 = 19
```
1. 2진수의 각 자리에 2의 거듭제곱을 할당한다.
2. 각 자리의 숫자에 해당 거듭제곱 값을 곱한다.
3. 곱한 값을 모두 더한다.

<br>

--- 
### 부호가 있는 2진수
- 2의 보수법
`2ⁿ - x`

```
 -7 = 2⁴ - 7 = 9 => 1001₂
```
- 위처럼 `2ⁿ - x` 식을 구할 수도 있고, 1의 보수를 만든 후 1을 더하는 방법도 있다.
- 2의 보수 = 1의 보수 + 1

```
 +7 => 0111₂
 // 1의 보수 (반전)
 1000₂
 // 1을 더함
 1001₂
```

- 덧셈과 뺄셈을 같은 방식으로 수행 가능하다.
```
 5 - 7 = 5 + (-7)
0101 + 1001 = 1110     : 이진수로 변환하여 덧셈한 값
-2 = 2⁴ - 2 = 14 => 1110₂   : 2의 보수법
 '14'
÷ 2 … 0 => LSB
----
  7
÷ 2 … 1
----
  3
÷ 2 … 1
----
  1
÷ 2 … 1 => MSB
----
  0

5 = 0101₂
7 = 0111₂
7의 1의 보수 = 1001₂
0101 + 1001 = 1110
```
- 자리 넘침(overflow)이 발생하면 최상위 비트는 버린다.

<br>

## 가산기
- 2진수를 더하는 회로로, ALU 에서 덧셈을 수행하는 핵심 부품

### 반가산기 (Half Adder)

- 입력: 2개의 비트 (A, B)
- 출력: 합(Sum, S)과 자리올림(Carry, C)
- 논리식:
  - 합 (S) = A + B의 LSB = A ⊕ B (XOR 게이트)
  - 자리올림 (C) = A + B의 MSB(자리올림) = A ∧ B (AND 게이트)

| A |	B |	Sum(S) |	Carry(C) |
|---|---|---|---|
| 0 | 0 | 0 | 0 |
| 0	| 1 |	1 |	0 |
| 1 |	0 |	1 |	0 |
| 1	| 1 |	0	| 1 |
